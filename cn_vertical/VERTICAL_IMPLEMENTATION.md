# LuaTeX 中文竖排实现原理

这份文档解释了本项目如何实现中文竖排，以及它与 `luatexja` 等其他解决方案的区别。

## 1. 核心矛盾：LaTeX 是一台“水平打字机”

默认情况下，LaTeX（以及底层的 TeX 引擎）是为西方语言设计的。它的工作方式就像一台从左到右移动的打字机，填满一行后移动到下一行。

要实现竖排，大多数解决方案都必须与这种“重力”做斗争。

---

## 2. 我们的实现方式：“网格坐标放字法”

我们没有试图教 LaTeX 如何“垂直打字”，而是将整个过程看作是**在网格上贴瓷砖**。

1.  **捕获（Capture）**：我们首先将用户的文本捕获到一个“黑盒子”（LaTeX 的 `\vbox`）中。在这个盒子内部，文本在技术上仍然是水平的，但我们保留了段落结构。
2.  **提取（Lua 介入）**：利用 LuaTeX 引擎的力量，我们在 Lua 中“打开盒子”并提取每一个字符（称为 `node`，节点）。
3.  **网格定位（Grid Positioning）**：
    *   我们不让 LaTeX 决定字符放在哪里。
    *   我们计算一个“稿纸网格”（类似于传统的“乌丝栏”）。
    *   我们的算法手动计算每个字符的精确 X 和 Y 坐标。
    *   字符在列内从上到下流动，列与列之间从右到左流动。
4.  **重新赋值**：我们根据网格计算结果，强制设置每个字符的坐标，将它们居中放置在指定的“格子”内。

**优点**：这种方法极其精确，非常适合要求字符必须严格对齐网格的古籍版式。

---

## 3. 方案对比：本项目 vs. `luatexja`

| 特性 | 传统方案 (如 `luatexja`) | 本项目 (基于网格) |
| :--- | :--- | :--- |
| **基本逻辑** | 修改 TeX 内部的断行和排版引擎。 | 绕过引擎，手动设置坐标。 |
| **复杂度** | 极高；需要重定义横向和纵向的排版规则。 | 较低；基于简单的网格填充算法。 |
| **网格对齐** | 很难实现完美的“稿纸”对齐。 | 原生支持严格的网格对齐。 |
| **灵活性** | 适合排版长篇现代流式文本。 | 完美适配古籍版式和精细控制。 |

### 总结

- **`luatexja`** 试图教“水平打字机”如何垂直打字。这是一个巨大的、复杂的工程，旨在让竖排感觉像是“原生”的功能。
- **本项目** 则是从打字机那里夺走字符，交给一位“排版艺术家”（Lua），由他将字符准确地放置在预先画好的网格上。这使得实现诸如强制换行、自动列缩放和传统边框等功能变得更加容易。
